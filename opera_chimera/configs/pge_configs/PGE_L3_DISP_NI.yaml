#######################################################################
# PGE configuration for L3_DISP_NI.
#######################################################################

# The runconfig section is intended to be used for dynamically generating the runconfig file used
# when running the OPERA PGEs. Any values set with a "__CHIMERA_VAL__" should be filled in by the input
# preprocessor. Otherwise, a precondition evaluation error will be raised by chimera.
#
# The runconfig section is also used as the data dict for the RunConfig jinja2 template.
# Accordingly, the schema here does NOT need to match the final RunConfig.yaml schema.
#
# * See RunConfig_schema.<label>.yaml for RunConfig.yaml documentation.
# * See related `RunConfig.yaml.<label>.jinja2.tmpl` file
#  and `util.conf_util.RunConfig.__init__()` for jinja2 usage.
runconfig:
  input_file_group:
    input_file_paths: __CHIMERA_VAL__
  dynamic_ancillary_file_group:
    algorithm_parameters_file: __CHIMERA_VAL__
    mask_file: __CHIMERA_VAL__
    dem_file: __CHIMERA_VAL__
    gunw_files: __CHIMERA_VAL__
    troposphere_files: __CHIMERA_VAL__
  static_ancillary_file_group:
    frame_to_bounds_json: __CHIMERA_VAL__
    reference_date_database_json: __CHIMERA_VAL__
  product_path_group:
    product_version: __CHIMERA_VAL__
    input_path: /home/mamba/input_dir
    product_path: /home/mamba/output_dir
    scratch_path: /home/mamba/scratch_dir
    save_compressed_slc: __CHIMERA_VAL__
  processing:
    polarization: __CHIMERA_VAL__
    frequency: __CHIMERA_VAL__
    frame_id: __CHIMERA_VAL__
    product_type: __CHIMERA_VAL__
    threads_per_worker: __CHIMERA_VAL__
    n_parallel_bursts: __CHIMERA_VAL__
    debug_switch: False
  cnm_version: "__CHIMERA_VAL__"

# This lists all the precondition evaluation steps that this PGE needs to run prior to running the PGE.
preconditions:
  - get_product_version
  - get_cnm_version
  - set_daac_product_type
  - get_disp_ni_sample_inputs

# TODO: Commenting out disp-s1 precondition functions & associated param sections as I suspect disp-ni will
# TODO:  eventually make use of similar functions so I'll leave them for future reference
#  - get_disp_s1_polarization
#  - get_disp_s1_frame_id
#  - get_disp_s1_product_type
#  - get_disp_s1_num_workers
#  - get_disp_s1_last_processed
#  - get_s3_input_filepaths
#  - get_static_ancillary_files
#  - get_disp_s1_compressed_cslc_files
#  - get_disp_s1_static_layers_files
#  - get_disp_s1_ionosphere_files
#  - get_disp_s1_mask_file
#  - get_disp_s1_dem
#  - get_disp_s1_save_compressed_slc

# This lists all the postprocessor steps that this PGE will run after running the PGE.
postprocess:
  - update_product_accountability

get_product_version:
  version_key: "DISP_NI_PRODUCT_VERSION"

set_daac_product_type:
  template: OPERA_L3_DISP_NI_{cnm_version}

#get_static_ancillary_files:
#  # The s3 locations of each of the static ancillary file types used by DISP-S1
#  algorithm_parameters_file:
#    # TODO: we'll need to support supplying a forward config as well at some point
#    settings_key: "DISP_S1.ALGORITHM_PARAMETERS_HISTORICAL_YAML"
#  frame_to_burst_json:
#    settings_key: "DISP_S1.FRAME_TO_BURST_JSON"
#  reference_date_database_json:
#    settings_key: "DISP_S1.REFERENCE_DATE_DATABASE_JSON"
#  algorithm_parameters_overrides_json:
#    settings_key: "DISP_S1.ALGORITHM_PARAMETERS_OVERRIDES_JSON"
#    download: true
#
#get_disp_s1_mask_file:
#  s3_bucket: "opera-water-mask"
#  s3_key: "v0.3/EPSG4326.vrt"

# This function will add to the PGE output metadata when product to dataset conversion is performed
set_extra_pge_output_metadata:
   daac_product_type: daac_product_type

# List the extensions that the PGE generates
output_types:
  L3_DISP_NI:
    - nc
    - h5
    - png
    - catalog.json
    - iso.xml
    - log
    - qa.log

# The PGE name
# This must MATCH the corresponding entry in pge_outputs.yaml
pge_name: "L3_DISP_NI"

# Set the primary input/output types here
primary_input: "L2_GSLC_NI"
primary_output: "L3_DISP_NI"

# We currently pull algorithm parameters from S3, so we do not need to enable
# generation from the template.
use_algorithm_parameters: false

# List the groups that Chimera will need to localize
# The entries MUST reference a property of `$.runconfig` of this YAML.
# The referenced properties MUST be maps.
localize_groups:
  - input_file_group
  - dynamic_ancillary_file_group
  - static_ancillary_file_group
  - processing


#######################################################################
# PGE Simulation Mode
#
# * See PGE_SIMULATION_MODE in settings.yaml and it's usage
# * See SIMULATE_OUTPUTS usage in opera_pge_wrapper.py and chimera.precondition_evaluator.py
#######################################################################
input_file_base_name_regexes:
    - '(?P<id>(?P<project>NISAR)_(?P<level>L2)_(?P<product_type>GSLC)_(?P<source>NI)_(?P<frame_id>F\d{3})_(?P<sensing_date_time>\d{8})T\d{6}Z_(?P<creation_ts>(?P<cre_year>\d{4})(?P<cre_month>\d{2})(?P<cre_day>\d{2})T(?P<cre_hour>\d{2})(?P<cre_minute>\d{2})(?P<cre_second>\d{2})Z)_(?P<sensor>NI)_(?P<pol>VV|VH|HH|HV)_(?P<product_version>v\d+[.]\d+))$'
sample_input_dataset_id: "NISAR_L2_GSLC_NI_F150_20070703T062138Z_20240528T200959Z_NI_HH_v0.1"
output_base_name: OPERA_L3_DISP-NI_{track}_{direction}_{frame_id}_{mode}_{pol}_{ref_datetime}Z_{sec_datetime}Z_{product_version}_{creation_ts}Z
ancillary_base_name: OPERA_L3_DISP-NI_{frame_id}_{pol}_{product_version}_{creation_ts}Z
compressed_gslc_name: compressed_{ref_date}_{first_date}_{last_date}
# TODO: Update when proper naming convention is established
#compressed_gslc_name: OPERA_L2_COMPRESSED-CSLC-S1_{disp_frame_id}_{burst_id}_{ref_date}T000000Z_{first_date}T000000Z_{last_date}T000000Z_{creation_ts}Z_{pol}_{product_version}
